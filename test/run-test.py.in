import json
import os
import re
import sys
import typing
from subprocess import check_output

topdir = os.path.abspath(os.path.join(os.path.abspath(os.path.dirname(__file__)), ".."))
bindir = os.path.join(topdir, "bin")
plugin = os.path.join(topdir, "gcc", "xgill.so")


def execfile(thefile, globals=None):
    exec(__builtins__.compile(open(thefile).read(), thefile, "exec"), globals)


if not os.path.exists("test-output"):
    os.mkdir("test-output")


# Simplified version of the body info.
class Body(dict):
    def __init__(self, body):
        self['BlockIdKind'] = body['BlockId']['Kind']
        if 'Variable' in body['BlockId']:
            self['BlockName'] = body['BlockId']['Variable']['Name'][0]
        self['LineRange'] = [ body['Location'][0]['Line'], body['Location'][1]['Line'] ]
        self['Filename'] = body['Location'][0]['CacheString']
        self['Edges'] = body.get('PEdge', [])
        self['Points'] = { i+1: body['PPoint'][i]['Location']['Line'] for i in range(len(body['PPoint'])) }
        self['Index'] = body['Index']
        self['Variables'] = { x['Variable']['Name'][0]: x['Type'] for x in body['DefineVariable'] }

        # Indexes
        self['Line2Points'] = {}
        for point, line in self['Points'].items():
            self['Line2Points'].setdefault(line, []).append(point)
        self['SrcPoint2Edges'] = {}
        for edge in self['Edges']:
            (src, dst) = edge['Index']
            self['SrcPoint2Edges'].setdefault(src, []).append(edge)
        self['Line2Edges'] = {}
        for (src, edges) in self['SrcPoint2Edges'].items():
            line = self['Points'][src]
            self['Line2Edges'].setdefault(line, []).extend(edges)

    def edges_from_line(self, line):
        return self['Line2Edges'][line]

    def edge_from_line(self, line):
        edges = self.edges_from_line(line)
        assert(len(edges) == 1)
        return edges[0]

    def edges_from_point(self, point):
        return self['SrcPoint2Edges'][point]

    def edge_from_point(self, point):
        edges = self.edges_from_point(point)
        assert(len(edges) == 1)
        return edges[0]

    def assignment_point(self, varname):
        for edge in self['Edges']:
            if edge['Kind'] != 'Assign':
                continue
            dst = edge['Exp'][0]
            if dst['Kind'] != 'Var':
                continue
            if dst['Variable']['Name'][0] == varname:
                return edge['Index'][0]
        raise Exception("assignment to variable %s not found" % varname)

    def assignment_line(self, varname):
        return self['Points'][self.assignment_point(varname)]


_, *tests = sys.argv
if not tests:
    tests = ['gchazard', 'gccbugs', 'memory']

for name in tests:
    indir = os.path.join(topdir, "test", name)
    outdir = os.path.join(topdir, "test", "test-output", name)
    if not os.path.exists(outdir):
        os.mkdir(outdir)

    def compile(source, env_mods={}):
        if source.endswith(".c"):
            compile = os.environ.get("CC", "@TARGET_CC@ -x c")
        else:
            compile = os.environ.get("CXX", "@TARGET_CC@ -x c++")
            compile += " -std=c++17"
        cmd = "{compile} -c {source} -fplugin={sixgill}".format(
            source=os.path.join(indir, source),
            compile=compile,
            sixgill=plugin
        )
        print("Running %s" % cmd)
        os.environ['CCACHE_DISABLE'] = '1'
        os.environ.update(env_mods)
        return check_output(["/bin/sh", "-c", cmd], text=True)

    def load_db_entry(dbname, pattern, require=True):
        output = check_output([os.path.join(bindir, "xdbkeys"), dbname + ".xdb"], universal_newlines=True)
        entries = output.splitlines()
        if not isinstance(pattern, typing.Pattern):
            pattern = re.compile(r'^' + pattern + '$')
        matches = [f for f in entries if re.search(pattern, f)]
        if len(matches) == 0:
            if require:
                raise Exception(f"entry /{pattern.pattern}/ not found in {dbname}")
            return []
        if len(matches) > 1:
            raise Exception(f"multiple entries found for /{pattern.pattern}/ in {dbname}")

        output = check_output([os.path.join(bindir, "xdbfind"), "-json", dbname + ".xdb", matches[0]], universal_newlines=True)
        return json.loads(output)

    def process_body(body):
        return Body(body)

    def process_bodies(bodies):
        return [process_body(b) for b in bodies]

    def equal(got, expected):
        if got != expected:
            print("Got '%s', expected '%s'" % (got, expected))

    os.chdir(outdir)
    execfile(os.path.join(indir, "test.py"))
