import os
import re
import json
from subprocess import check_output

topdir = os.path.abspath(os.path.join(os.path.abspath(os.path.dirname(__file__)), ".."))
bindir = os.path.join(topdir, "bin")
plugin = os.path.join(topdir, "gcc", "xgill.so")

if not os.path.exists("test-output"):
    os.mkdir("test-output")

# Simplified version of the body info.
class Body(dict):
    def __init__(self, body):
        self['BlockIdKind'] = body['BlockId']['Kind']
        if 'Variable' in body['BlockId']:
            self['BlockName'] = body['BlockId']['Variable']['Name'][0]
        self['LineRange'] = [ body['Location'][0]['Line'], body['Location'][1]['Line'] ]
        self['Filename'] = body['Location'][0]['CacheString']
        self['Edges'] = body.get('PEdge', [])
        self['Points'] = { i+1: body['PPoint'][i]['Location']['Line'] for i in range(len(body['PPoint'])) }
        self['Index'] = body['Index']
        self['Variables'] = { x['Variable']['Name'][0]: x['Type'] for x in body['DefineVariable'] }

        # Indexes
        self['Line2Points'] = {}
        for point, line in self['Points'].items():
            self['Line2Points'].setdefault(line, []).append(point)
        self['SrcPoint2Edges'] = {}
        for edge in self['Edges']:
            (src, dst) = edge['Index']
            self['SrcPoint2Edges'].setdefault(src, []).append(edge)
        self['Line2Edges'] = {}
        for (src, edges) in self['SrcPoint2Edges'].items():
            line = self['Points'][src]
            self['Line2Edges'].setdefault(line, []).extend(edges)

    def edges_from_line(self, line):
        return self['Line2Edges'][line]

    def edge_from_line(self, line):
        edges = self.edges_from_line(line)
        assert(len(edges) == 1)
        return edges[0]

    def edges_from_point(self, point):
        return self['SrcPoint2Edges'][point]

    def edge_from_point(self, point):
        edges = self.edges_from_point(point)
        assert(len(edges) == 1)
        return edges[0]

    def assignment_point(self, varname):
        for edge in self['Edges']:
            if edge['Kind'] != 'Assign':
                continue
            dst = edge['Exp'][0]
            if dst['Kind'] != 'Var':
                continue
            if dst['Variable']['Name'][0] == varname:
                return edge['Index'][0]
        raise Exception("assignment to variable %s not found" % varname)

    def assignment_line(self, varname):
        return self['Points'][self.assignment_point(varname)]

tests = ['gchazard']
for name in tests:
    indir = os.path.join(topdir, "test", name)
    outdir = os.path.join(topdir, "test", "test-output", name)
    if not os.path.exists(outdir):
        os.mkdir(outdir)

    def compile(source):
        cmd = "{CXX} -c {source} -fplugin={sixgill}".format(source=os.path.join(indir, source),
                                                            CXX=os.environ.get("CXX", os.environ.get("CC", "@TARGET_CC@")),
                                                            sixgill=plugin)
        print("Running %s" % cmd)
        os.system(cmd)

    def load_db_entry(dbname, pattern):
        output = check_output([os.path.join(bindir, "xdbkeys"), dbname + ".xdb"])
        entries = output.splitlines()
        matches = [f for f in entries if re.search(pattern, f)]
        if len(matches) == 0:
            raise Exception("entry not found")
        if len(matches) > 1:
            raise Exception("multiple entries found")

        output = check_output([os.path.join(bindir, "xdbfind"), "-json", dbname + ".xdb", matches[0]])
        return json.loads(output)

    def process_body(body):
        return Body(body)

    def process_bodies(bodies):
        return [ process_body(b) for b in bodies ]

    def equal(got, expected):
        if got != expected:
            print("Got '%s', expected '%s'" % (got, expected))

    os.chdir(outdir)
    execfile(os.path.join(indir, "test.py"))
